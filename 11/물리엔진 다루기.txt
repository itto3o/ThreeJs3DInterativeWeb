물리엔진과 three.js의 관계

물리엔진은 자연에서 일어나는 물리 현상을 수학적으로 연산해서 직접 구현하려면 굉장히 어려울테니까,
이걸 자동으로 해주는 물리엔진 라이브러리를 갖다쓰기
캐논js는 사용하기 제일 쉬움, 기능들이 비슷하기때문에 다른거할때도 도움이 될 것

불투명한 색깔있는 컵은 mesh, 캐논js에서 만든 body의 오브젝트가 있따면
바디는 눈에 보이지 않음, 물리적으로 연산되고 연산이 적용되는 애,
우리가 원하는건 mesh를 공중에 놓고 떨어뜨리는 것, mesh에는 그런 기능이 없고
캐논js의 body를 이용해서 중력을 설정해주면 떨어짐
튕기거나, 넘어지거나 등등을 해줌

얘도 meshㅇ와 마찬가지로 위치, 회전값을 갖고 있는데 얘 위치를 mesh가 따라가게 만들면 됨
copy해서 그대로 따라가게끔
(결합이 된 상태로 같이 떨어지는 것처럼 보이게끔)
three.js에서 만든 mesh와 cannon.js에서 만든 body는 함께 따라가게 됨


----------------------------------------------
물리엔진 월드 생성

vscode에서 열기, 패키지 설치, three.js 설치

cannon.js 공식문서를 가보면 필요한걸 검색해보기

orbitControls 추가

three.js까지 설치를 해줬었는데, cannon.js는 외부라이브러리라서 따로 설치해주기
--> npm i cannon
오래돼서 업데이트가 안되어서 , es버전이 더 최신화되어 있어서
npm i cannon-es를 해주면 됨
three 코어 가져오는 식으로
import * as CANNON from 'cannon-es'로
--> CANNON. 으로 접근 가능

cannon에 월드를 만들어줘야함
new CANNON.World();

캐논 월드에 중력을 세팅해줘야함
--> 물리현상들이 자연스럽게 일어남
지구 중력, 달 중력이 다르듯이 중력가속도를 다르게 세팅해줄 수 있음
지구 중력가속도는 9.8, 지구랑 비슷하게 하려면 10정도
cannonWorld.gravity.set()
three.js에서 set할때 축 별로 세팅해줄 수 있었는데, 위에서 아래로 떨어지는거니까 y만 해주면 됨
--> set(0, -10, 0) : -로 해줘야 밑으로 떨어짐

큐브를 떨어뜨릴건데,
바닥을 추가해주기
--> 바닥도 역시 캐논에서 만들어줘야하지만 mesh가 일하는것
--> plane mesh를 깔아주기

const floorMesh = new ThREE.Mesh(
new THREE.PlaneGeometry(10, 10),
new THREE.MeshStandardMaterial(color : 'slategray'})
)

한번에 만들기, geometry, material를 따로 만들어줬지만 지금은 그냥 한번에 하기
(floor는 다른데서 쓸 일이 없을 거라)

scene.add(floorMesh)를 하면 plane이 세워져있음
--> floorMesh.ratation.x = (90도니까) Math.PI/2;
--> 이렇게 하면 안보임, 앞면이 바닥에 깔려서 뒷면은안보임, --> 앞면이 위로 오도록 앞에 -를 붙이기

이런 meshㄹ르 바닥 위에 놓을때는 mesh 높이의 절반 만큼을 y값을 올려줘야함
box의 높이가 1이니까, box의 y포지션을 0.5로 해줘야 바닥 위로 올라오게됨



--> cannon에서 세팅해주기
cannon에서도 바닥, box도 똑같이 필요함
(다음 시간에)



------------------------------
물리가 적용되는 객체 만들기

three.js에서는 geometry = shape으로 부름, 
floorBody를 만들고, 얘가 물리혀상이 적용돼서 실제로 움직이는 애
new CANNON.Body( { mass :

바닥은 고정되어있어야하기 때문에(얘가 고정되어있지 않으면 같이 끝없이 떨어지기 때문에:)
그래서 0위치에서 -방향으로 낙하한다는 말,
그렇게 안되게 하려면 mass: 0으로 하면 중력의 영향을 안받음 --> 바닥의 역할을 하기 위해

position: new CANNON.Vec3(0, 0, 0) --> 위치 설정
어떤 형태를 쓸건지 shape : floorShape

이 만든 바디를 cannonWorld.addBody(floorBody)로 하면 됨

cannon plane도 마찬가지로 plane mesh처럼 기본적으로 서있는데, 얘도 three.js에서처럼 회전해야함
회전할때 quaternion을 써줘야함
floorBody.quaternion (사원수, 해밀턴 수), .setFromAxisAngle(축각도에서 세팅)();
각도, 축을 인자로 넣어줘야함
축도 vec3로 함
new CANNON.Vec3(x축 기준으로 90도니까 벡터좌표에서는, 0,0,0기준에서는 x방향으로 가면 되니까 -1, 0,0 해주면 됨
0 1 0이면 y축이ㅗㄱ
각도는 radian
Math.PI / 2


box Shpae도 만들기
const boxShape = new CANNON.Box();
three.js에서와는 좀 다름, three.js에서는 가로, 세로, 깊이를 숫자로 정하는 건데
cannon.js는중심을 기준으로 얼만큼 갈건지
--> three.js에ㅓㅅ 1, 1,1이었다면 이것의 반을 해줘야함(반지름 느낌으로)
--> 0.5 0.5 0.5대신vec3(0.5, 0.5, 0.5)로 해주기

boxBody도 만들기 new CANNON.Body({mass: 1
얘도 단위가 없기 때문에 단위는 상대적으로 알아서 생각하기
position : new CANNON.Vect3(0, 3, 0) --> 살짝 띄워주기

cannonWorld에 addBody로 넣어주기

--> MEsh, 물리적으로 컨트롤해줄 body를 만들었음
--> 이후 이 둘을 draw함수에서 연결해주기

cannonworld.step()으로 시간 단계 설정
처음에 고정된 시간 단위, 몇분에 1초 간격으로 갱신해줄건가 --> draw함수는 초당 60프레임, 60분에 1초를 목표를 목표로 하고 있음
step(1/60, delta, 3);
성능보정으로 delta와 같은 시간 차를 이용했었는데, 이 인자를 넣어주면 됨
잠재적으로 차이가 벌어질 수 있어서 이 간격을 메우는 시도를 몇번을 해줄건지 횟수 세팅

--> 주사율에 따라 다른데, 그냥 1/60으로 하게 되면 고정값이되니까, 주사율이 120인 곳에서는 더 부드럽게 구현할 수 있음에도 덜 부드럽게 구현하게 되는 게 될 수 있어서
완전히 얇은 벽은 뚫고 나가는 현상이 있다던지
--> 프레임, 화면주사율이 일치하지 않아서 그럼

--> 그런데 고정된 갑슬 넣어야하기 때문에 그래서 화면 주사율에 따라 유동적으로 대응하면 좋을 것 같아서,
--> 퀄리티를 높이기 위해 delta를 가지고 정해주는 걸로 수정하기

delta는 draw함수 시간 간격인데, delta를 출력해보면 초당 60프레임을 그려주는 애니까 0.16~0.17 왔다갔다 했었는데, 120프레임에서는 0.008, 0.007 이렇게 나옴
--> delta값에 따라서 변수를 맞춰주기

let cannonStepTime = 1/60;
if(delta < 0.01)dlfkaus cannonStepTime = 1/120;
delta값에 따라서 steptime을 바꿔주기
--> 작업을 따로해주기

cannonBody위치를 mesh가 따라가도록 하기
position을 그대로 복사하기
floorMesh.position.copy(floorBody.position) --> 인자를 그대로 복사하는 함수
box도 마찬가지로 해주기
--> 이렇게 하면 박스가 떨어짐

boxMesh.position.y = 0.5로 처음에 코드에서 세팅을 했었지만, 얘는 딱 처음에 한번 실행되는거고
draw함수에ㅓㅅ 계속 실행되는 boxBody.positon을 따라가기 때문에 boxMesh.position은 3으로 해놨고 3에서 중력이 작동하니까 떨어짐

지금은 floor에서 딱 멈추고 있는데 floorBody의 mass를 1로 바꾸면 같이 함께 떨어짐
외부 충격에 가만히 있어야한다면 mass를 모두 0으로 해놔야함

실제 mass가 클수록 무겁기 때문에 외부 충격에 많은 충격을 받음

여기서 손볼게 있는데,
박스가 정육면체인데 넘어질 일이 없음, --> 홀쭉한 박스로 바꾸고 충격받으면 넘어져야하니까

box를 1,1,1이 아니라 0.5 5 0.5로 하기
--> cannonBoxyShpae도 바꿔주기 0.25, 2.5, 0.25로 바꾸고
position도 5에서 떨어뜨리기

--> 떨어졌는데 움직이는데 느낌이 이상함
--> 미끄러지다가 갑자기 바닥이 뚫림
--> cannonBody는 넘어졌는데 mesh가 안넘어져서 그럼
우리가 draw함수에ㅓㅅ boxbody Position을 그대로 카피해ㅓㅅ 이동시키는건데, 회전은 따로 해줘야함
회전도 따로 카피해줘야함

boxMesh.quaternion.copy(boxBody.quaternion)
--> three.js에서는 rotation함수를 써서 회전을 했지만 quaternion으로도 회전이 가능함, cannon.js에서 회전을 quaternion으로 했기 때문
--> 넘어지게 됨

three.

나는 안되길래 왜안되지 하면서 보니까 오타남..^^..Box를 Body로쓰고앉았네