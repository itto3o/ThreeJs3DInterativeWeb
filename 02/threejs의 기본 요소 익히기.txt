수업 자료에 있는 이미지를 먼저 이해하고 시작

무대가 Scene, 무대 위에 배우, 소평, 조명, 카메라가 다 무대 위에 올라감
배우가 하나지만 다른 소품들, 자동차, 물체들, object하나하나가 mesh
mesh는 geometry(모양), material(재질)로 구성됨
재질은 색깔, 거친 표면의 느낌, 맨질맨질한 느낌 등

카메라가 있음,
시야각이라는 걸 가짐(어느정도의 시야로 표현해줄 것인가)
동물마다 시야각이 다 다른데, 각도가 다 다름-->왜곡되어있는 게 다 다름

조명도 있음
재질이 어떤 거냐에 따라 필요없을수도
조명이 없어도 눈에 보이거나, 조명이 있어야 눈에 보일수도

화면에 그려주는 애가 renderer(장면을 볼때는 카메라가 비추는 영역, 각도로 카메라 입장에서 보임)
--> 카메라가 보여주는 장면을 보여주고 있음

중요한건 위치,
threejs는 3차원이니까 축의 방향의 기준은 카메라가 보고 있는 곳이 정면이라고 하면,
x축은 좌우, y축은 위아래, 위로가는게 +아래가 -, z가 앞뒤, 앞으로 나오면 +, 뒤로 가면 마이너스

-------------------------------------------
기본장면 만들기 - renderer

02_basic을 열고
터미널을 열어서 npm i 로 패키지 설치하기
npm i three로 threejs도 설치
src에 index.html을 만듦
새파일ㅇ르 만들어서 main.css를 만들기
body 마진 0
main.js도 생성, 이곳에 three.js
import 먼저

threejs를 구성하는 애중에 renderer를 먼저 만들기
renderer에 사이즈 지정, 풀스크린으로 할거니까 innerWidth, innerHeight
renderer.domElement가 있는데 얘가 캔버스, 화면에 조립을 해서 보여주면 됨
--> document.body.appendChild로 조립
이 캔버스에 three.js로 그려주는것
이렇게 하는 방법도 있고
html에 canvas를 만들고 걔를 가져와서 처리하는 방법도 있음,
canvas를 html에 직접 써주고 걔를 활용하는게 활용범위가 넓다고 생각됨, three.js로 뭔가 만들때 body에 canvas만 있다는 가정은 할 수 없고
여러 요소가 있을 텐데, 이 캔버스도 다른 요소들과 같이 위치를 지정해두는 편이 더 편함, 좀더 직관적이고(js에서 동적으로 하는 것보다)
둘다 노상관

--> html에 canvas에 id를 주기
main.css에서 threecanvas를 조정해주기
그냥놔두면 스크롤바가 생길 수 있는데 방지하기 위해 position을 absolute, left0 top0
앱솔루트는 다른 요소에 관련없이 위에 붕떠있는것처럼 조정되기 때문에

똑같이 render를 만드는데 canvas의 속성값을 canvas로 주기

-----------------------------------
camera

scene만들기
newTHREE.Scene()으로

카메라는 두개있는데, 원근 카메라(perspective 카메라)가 제일 많이 쓰임
인자 중에
1. 시야각(field of view, fov), 2.aspect 절두체 종횡비(비율 : 높이/너비) 3.near : 화면 얼마나 가까이오면 보일지, 얼마나 멀리가야 안보일지 4.far near가 가까운 쪽, far가 먼쪽
만약 near보다 가까이있으면 안보이게 되고, far보다 멀어도안보임
시야각은 양옆, 상하을 얘기하는듯
--> mesh는 near와 far사이에 있고 시야각 안에 들어와야 보임

시야각은 75정도, aspect는 브라우저 창사이즈의 높이/너비, near는 보통 0.1정도, 1000정도
카메라를 만든 후에는 scene.add를 통해 add해줘야함

scene에서 카메라 위치 설정을 안했으면 0 0 0으로세팅됨
--> 카메라와 mesh가 같이있으면 안보일테니까 보통카메라를 약간 뒤로빼줌
--> 앞뒤방향이니까z쪽, camera.position.z = 5; (단위는 개념적, 우리가 만드는 게 뭔지에 따라 상상하면 됨)
(만약 실내공간을 만든다면 m로 생각하면 됨)
블렌더에서도 같은 사이즈를 씀

----------------------------------
Mesh
무대 위의 객체, geometry + material
각각을 만들어서 그 두개를 조합함

가장 기본적인 모형은 직육면체
geometry = new THREE.BoxGeometry(1, 1, 1);
사이즈를 인자로 주는데, 미터로 가정한다면 1m짜리씩
meterial = new THREE.MeshBasicMaterial() // 가장 기본
오브젝트를 인자로 넣어서 호출함
--> { }로 감싸서 json처럼 인자를 넣어주고,
color는 기본적으로는 0xff0000(빨간색), 그냥 css의 컬러값으로 넣을 수 있는 애들은 다 넣어짐('red', '#ff0000'이런 식으로)

이 둘을 조합,
new THREE.Mesh(geometry, meterial);
이후 scene.add로 올려야함
얘가 보이려면 renderer로 그려줘야함
renderer.render(scene, camera);
(카메라를 같이 넣는 이유는 카메라를 여러대 사용할 수 있고, 어떤 카메라를 사용해서 render할건지를 선택할 수 있다)

입체 직육면체를 만들었는데 정사각형으로 보임
--> 카메라가 정면에 있어서 그렇다. (z로 5땡겼으니까)
--> 카메라를 살짞 위로, y를 2로, x를 1만큼

meshbasicmetrial이 조명을 안받는 재질이라 조명이 없어도 눈에 잘 보임

지금 살짝 계단 현상이 있음, 안티 앨리어싱 처리가 안됨, 이거를 renderer에서 canvas 뒤에 ,antialias:true로 하면 부드러워짐(하지만 성능은 조금 떨어짐)
그렇게 엄청 성능저하는 아니지만, 얼마나 복잡한 걸 돌리냐에 따라 차이가 있음

라이브서버로 띄울땐 안띄워지던데 npm start하니까 되네 뭐지

----------------------------------
직교 카메라
Orthographic(직교 카메라)해보기

perspective카메라와 orthographic 카메라의 차이
자연스럽게 사람 눈으로 보는 것처럼 원근이 적용 되어있는데,
orthographic은 원근에 따라 물체의 크기가 다르지 않고, 크기는 똑같음, 격자도 일정
게임 중에 디아블로, 롤같은 게임들, 쿼터뷰에서 많이 씀, 특정한 목적이 있을 때 사용함
left, right, top, bottom
카메라 절두체는 near, far를 받고있는 면들을 위아래로 하는 원뿔모양?의 도형을 말함,
orthographic 카메라는 직육면체일 것임(원근이 없기 때문)
일반적으로 많이 쓰는 비율로 만들자면,
left는 -, right는 +, top은 1, bottom은 -1, near은 0.1, far은 1000
camera.position을 바꿔줘도 물체가 안보임 (카메라가 너무 위로 올라와서)
큐브를 바라보게 할 경우
camera.lookAt(0, 0, 0)으로 원점(큐브가 있는 곳)을 바라보게 할 수 있음
카메라 자체에서 줌을 할 수도 있음
camera.zoom = 0.5;
--> 하지만 변화가 없는데, 이러한 렌더 속성을 바꿨다면 updateProjectionMatrix(); 메소드를 호출해야함

zoom을 안하고 z를 10으로 늘린다면?
--> 다시 커짐
100으로 하면? 뷰가 좀 달라짐
z위치를 옮기면 카메라가 뒤로 가서 조그맣게 보였엇는데, 직교카메라는 동작이 헷갈림(뷰 각도에 영향을 주기 때문)
-->zoom out을 하려면 zoom을 건드려야 한다, 그리고 updateProjectionMatrix를 호출해야 한다


