수업 자료에 있는 이미지를 먼저 이해하고 시작

무대가 Scene, 무대 위에 배우, 소평, 조명, 카메라가 다 무대 위에 올라감
배우가 하나지만 다른 소품들, 자동차, 물체들, object하나하나가 mesh
mesh는 geometry(모양), material(재질)로 구성됨
재질은 색깔, 거친 표면의 느낌, 맨질맨질한 느낌 등

카메라가 있음,
시야각이라는 걸 가짐(어느정도의 시야로 표현해줄 것인가)
동물마다 시야각이 다 다른데, 각도가 다 다름-->왜곡되어있는 게 다 다름

조명도 있음
재질이 어떤 거냐에 따라 필요없을수도
조명이 없어도 눈에 보이거나, 조명이 있어야 눈에 보일수도

화면에 그려주는 애가 renderer(장면을 볼때는 카메라가 비추는 영역, 각도로 카메라 입장에서 보임)
--> 카메라가 보여주는 장면을 보여주고 있음

중요한건 위치,
threejs는 3차원이니까 축의 방향의 기준은 카메라가 보고 있는 곳이 정면이라고 하면,
x축은 좌우, y축은 위아래, 위로가는게 +아래가 -, z가 앞뒤, 앞으로 나오면 +, 뒤로 가면 마이너스

-------------------------------------------
기본장면 만들기 - renderer

02_basic을 열고
터미널을 열어서 npm i 로 패키지 설치하기
npm i three로 threejs도 설치
src에 index.html을 만듦
새파일ㅇ르 만들어서 main.css를 만들기
body 마진 0
main.js도 생성, 이곳에 three.js
import 먼저

threejs를 구성하는 애중에 renderer를 먼저 만들기
renderer에 사이즈 지정, 풀스크린으로 할거니까 innerWidth, innerHeight
renderer.domElement가 있는데 얘가 캔버스, 화면에 조립을 해서 보여주면 됨
--> document.body.appendChild로 조립
이 캔버스에 three.js로 그려주는것
이렇게 하는 방법도 있고
html에 canvas를 만들고 걔를 가져와서 처리하는 방법도 있음,
canvas를 html에 직접 써주고 걔를 활용하는게 활용범위가 넓다고 생각됨, three.js로 뭔가 만들때 body에 canvas만 있다는 가정은 할 수 없고
여러 요소가 있을 텐데, 이 캔버스도 다른 요소들과 같이 위치를 지정해두는 편이 더 편함, 좀더 직관적이고(js에서 동적으로 하는 것보다)
둘다 노상관

--> html에 canvas에 id를 주기
main.css에서 threecanvas를 조정해주기
그냥놔두면 스크롤바가 생길 수 있는데 방지하기 위해 position을 absolute, left0 top0
앱솔루트는 다른 요소에 관련없이 위에 붕떠있는것처럼 조정되기 때문에

똑같이 render를 만드는데 canvas의 속성값을 canvas로 주기

-----------------------------------
camera

scene만들기
newTHREE.Scene()으로

카메라는 두개있는데, 원근 카메라(perspective 카메라)가 제일 많이 쓰임
인자 중에
1. 시야각(field of view, fov), 2.aspect 절두체 종횡비(비율 : 높이/너비) 3.near : 화면 얼마나 가까이오면 보일지, 얼마나 멀리가야 안보일지 4.far near가 가까운 쪽, far가 먼쪽
만약 near보다 가까이있으면 안보이게 되고, far보다 멀어도안보임
시야각은 양옆, 상하을 얘기하는듯
--> mesh는 near와 far사이에 있고 시야각 안에 들어와야 보임

시야각은 75정도, aspect는 브라우저 창사이즈의 높이/너비, near는 보통 0.1정도, 1000정도
카메라를 만든 후에는 scene.add를 통해 add해줘야함

scene에서 카메라 위치 설정을 안했으면 0 0 0으로세팅됨
--> 카메라와 mesh가 같이있으면 안보일테니까 보통카메라를 약간 뒤로빼줌
--> 앞뒤방향이니까z쪽, camera.position.z = 5; (단위는 개념적, 우리가 만드는 게 뭔지에 따라 상상하면 됨)
(만약 실내공간을 만든다면 m로 생각하면 됨)
블렌더에서도 같은 사이즈를 씀

----------------------------------
Mesh
무대 위의 객체, geometry + material
각각을 만들어서 그 두개를 조합함

가장 기본적인 모형은 직육면체
geometry = new THREE.BoxGeometry(1, 1, 1);
사이즈를 인자로 주는데, 미터로 가정한다면 1m짜리씩
meterial = new THREE.MeshBasicMaterial() // 가장 기본
오브젝트를 인자로 넣어서 호출함
--> { }로 감싸서 json처럼 인자를 넣어주고,
color는 기본적으로는 0xff0000(빨간색), 그냥 css의 컬러값으로 넣을 수 있는 애들은 다 넣어짐('red', '#ff0000'이런 식으로)

이 둘을 조합,
new THREE.Mesh(geometry, meterial);
이후 scene.add로 올려야함
얘가 보이려면 renderer로 그려줘야함
renderer.render(scene, camera);
(카메라를 같이 넣는 이유는 카메라를 여러대 사용할 수 있고, 어떤 카메라를 사용해서 render할건지를 선택할 수 있다)

입체 직육면체를 만들었는데 정사각형으로 보임
--> 카메라가 정면에 있어서 그렇다. (z로 5땡겼으니까)
--> 카메라를 살짞 위로, y를 2로, x를 1만큼

meshbasicmetrial이 조명을 안받는 재질이라 조명이 없어도 눈에 잘 보임

지금 살짝 계단 현상이 있음, 안티 앨리어싱 처리가 안됨, 이거를 renderer에서 canvas 뒤에 ,antialias:true로 하면 부드러워짐(하지만 성능은 조금 떨어짐)
그렇게 엄청 성능저하는 아니지만, 얼마나 복잡한 걸 돌리냐에 따라 차이가 있음

라이브서버로 띄울땐 안띄워지던데 npm start하니까 되네 뭐지

----------------------------------
직교 카메라
Orthographic(직교 카메라)해보기

perspective카메라와 orthographic 카메라의 차이
자연스럽게 사람 눈으로 보는 것처럼 원근이 적용 되어있는데,
orthographic은 원근에 따라 물체의 크기가 다르지 않고, 크기는 똑같음, 격자도 일정
게임 중에 디아블로, 롤같은 게임들, 쿼터뷰에서 많이 씀, 특정한 목적이 있을 때 사용함
left, right, top, bottom
카메라 절두체는 near, far를 받고있는 면들을 위아래로 하는 원뿔모양?의 도형을 말함,
orthographic 카메라는 직육면체일 것임(원근이 없기 때문)
일반적으로 많이 쓰는 비율로 만들자면,
left는 -, right는 +, top은 1, bottom은 -1, near은 0.1, far은 1000
camera.position을 바꿔줘도 물체가 안보임 (카메라가 너무 위로 올라와서)
큐브를 바라보게 할 경우
camera.lookAt(0, 0, 0)으로 원점(큐브가 있는 곳)을 바라보게 할 수 있음
카메라 자체에서 줌을 할 수도 있음
camera.zoom = 0.5;
--> 하지만 변화가 없는데, 이러한 렌더 속성을 바꿨다면 updateProjectionMatrix(); 메소드를 호출해야함

zoom을 안하고 z를 10으로 늘린다면?
--> 다시 커짐
100으로 하면? 뷰가 좀 달라짐
z위치를 옮기면 카메라가 뒤로 가서 조그맣게 보였엇는데, 직교카메라는 동작이 헷갈림(뷰 각도에 영향을 주기 때문)
-->zoom out을 하려면 zoom을 건드려야 한다, 그리고 updateProjectionMatrix를 호출해야 한다


--------------------------------------
소스코드 구조 잡기
공부진행하는 편의상 소스 구조를 바꾸기

webpack에서 main.js를 엔트리파일로 지정해놔서 main.js에 코드를 작성해놨는데, 이 구조에서는 다른 예제를 하려면 통째로 따로 구성해야함
main.js를 다른 이름으로 바꿔놓고 새롭게 main.js를 만들어놔야 하니까
--> 좀 더 편한 구조로 바꾸기

예제에 대한 메인 코드는 main.js에서 작성하는게 아니라 다른 모듈로 만들고, main.js는 import
--> ex01.js라는 새 파일 만들고
main.js에 있던 내용을 복붙, 함수를 만들어서 default export하고 main.js에서는 그걸 갖다쓰는 형태로 만들예정


-----------------------------------------
창사이즈 변경에 대응하기
창사이즈가 바뀌면 같이 줄어들고 늘어나도록

ex01.js를 02버전으로 또 만들기
renderer에서 할 수 있음, window의 resize의 이벤트를 받아서 처리해주면 됨
--> 아래에 이벤트 처리
이벤트 핸들러로 setSize라는 함수가 호출되도록
먼저 카메라 조정을 해야함, 창사이즈가 바뀐다는건 종횡비가 바뀐다는 것, 카메라에 종횡비 세팅을 했었는데 이걸 다시 설정해주면 됨(똑같은 계산 방법으로)
카메라에 변화가 있을 때 카메라에 updateProjectionMatrix()를 실행해야함

이렇게 한 상태에서 해보면 변화가 없음,
--> renderer로 다시 그려주는 것까지 해줘야함
renderer.setSize로 사이즈 잡아주고, 다시 render를 해줘야함

캠버스 사이즈가 창 크기 그대로인데,
캔버스도 이미지와 마찬가지로 고해상도 표현을 하려면 크기를 더 크게 만들어준 다음에 걔를 줄여서 표현을 해줘야함
--> 화면들이 고해상도 화면이 많아졌는데, 실제 물리적인 픽셀과 화면 픽셀이 다름, 세밀하게 고해상도 이미지가 되니까

100px를 표현하려고 200px로 만든 다음에 100으로 줄여서 하면 세밀하게 고해상도 이미지가 되는 것과 같은 원리로,
고해상도 보더라도 고해상도로 표시가 안되어 있어서(캔버스가 창사이즈 그대로라서)
--> 2배로 크게 만들어서 줄여줘야 함
--> renderer.setSize부분에 

console.log(window.devicePixelRatio); 를 입력해서 그 기기의 픽셀 밀도를 숫자로 나타내주는데 ㅇ걸 찍어봐야함
강사는 2,(맥북이라 그런가 ㄷㄷ)
나는 1.25네
2는 100px을 표현할때 200px을 쓴다는 뜻

얘를가져와서 이 값으로 세팅해주면 됨 renderer.setPixelRatio함수에 값을 설정
canvas가 이제 2배가 됨
자동으로 css가 들어가 있음, 실제 이미지는 2배이지만 css에서 width height를 다시 절반으로 줄여주는 코드가 자동으로 들어가 있음
--> 고밀도 이미지가 됨

window.devicePixelRatio가 숫자가 안떨어질 경우도 있고 3일 경우도 있는데 2배정도만 해도 다 깨끗하게 잘 보임, 성능도 우수함
1:1아님 2:1이라
--> 1보다 크다면 2로 하고, 아니라면 1로 해주기


-----------------------------
배경의 색, 투명도 설정하기

ex02파일을 03으로 save as 저장, main.js에서 03실행

renderer를 만들때 옵션을 alpha:true --> 투명해짐
검은색이 투명해진건지, 하얀색이 된건지 구분이 안되니까 css에서 배경색을 넣어주기
원래 상태에서(true로 안줬을 때는) css에 배경색을 넣어도 티가 안나는데, alpha true를 한 뒤에는 파란색이 나옴

이 투명을 살짝 반투명하게 하고 싶다면 renderer.setClearAlpha() 인자를 숫자로 0~1를 넣어줄 수 있음, 0.5는 50% 불투명
색깔을 넣으려 한다면
rednerer.setClearColor()에 색깔 넣기, 인자로 0x00ff00으로 하면 연두색, '#00ff00'도 가능
이 상태에서 다시 setClearAlpha로 0.5를 지정하면, 뒤에 css로 넣은 dogerblue가 있어서 청록색이 됨,
그 css를 주석처리하면 연두색에서 좀 더 파스텔색이 됨
--> 이 두개를 조합해서 배경색 만들 수 있음

이번엔 렌더러가 아니라 scene에서 배경색 설정, scene자체는 무대니까 , scene에 있는게 더 우선순위가 높고 render위에 scene이 있음
scene에 background를 하면 renderer에 설정한건 묻힘
scene.background = <<여기에 숫자를 넣어야하는데 위에서 썼던 css방식은 숫자가 아니니까 three.js에서 지원하는 color를 만들기
new THREE.Color('blue'); 이렇게

배경 자체에 투명도를 적용한다고 하면 renderer에서 해야함

--------------------------------------------
빛(조명, light)

save as로 04번으로 만들기

const light = new THREE.DirectionalLight(0xffffff, 1)하면 아무변화 x
1은 빛의 강도를 뜻함, 0.5로 바꾸면 어두워짐 10으로하면 더 밝아짐, 100으로 하니까 큐브 자체가 하애지는 느낌
빛도 scene에 추가해줘야함,
그래도 변화가 없는데,
지금 빨간색 큐브는 mesh가 meshBasicMaterialㅓ로 되어있는데 얘는 빛에 반응을 안함, 빛이 없어도 변화 x
--> 다른 애로 바꾸고 MeshStarndardmaterial로
--> 정육면체 윗면만 보임, directionalLight가 태양빛이랑 비슷하다고 생가갛면됨(무대위를 전체적으로 비춤, 머리 위에서 내리쬐는중)
정육면체가 살짝 왼쪽에 치우친 거는 카메라를 이동했기 때문, --> 빛도 position을 움직일 수 있음
z를 5로 하면 앞으로 땡겨옴, 빛이 땡겨진거라 앞면이 더 많이 보이게 됨

조명은 여러개를 add할 수 있고, 너무 많으면 성능에는 좀 영향이 있음

-------------------------------------------

