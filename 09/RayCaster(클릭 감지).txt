RayCaster의 동작 원리

레이는 엑스레이할때 광선,

광선은 무한한 직선, mesh에 맞는데, 맞았다면 관통을해서 맞았다고 인지가 됨

--> mesh가 두개있다면 걔네 둘다관통함
--> ㅇ걸로 클릭을 감지할 수 있음

카메라에서 광선을 쏘고, mesh를 통과하면 클릭됐다고 판정을 함,
mesh들이 겹쳐있다면 둘다 선택이 됨
만약에 앞에 있는 것만 선택을 하고 싶다면 mesh 하나를 맞은 순간에 그만둘 수 있음

threejs 자체가 canvas판에서 그림으로 그려지는 거라 dom이런게 없음,
ray를 casting한다고 해서 레이캐스터라고 부름


----------------------------
준비 - Line으로 선 마들고 메쉬 배치하기

npm 으로 설치

특정 방향의 광선에 맞은 mesh 판별하기
임의의 위치에 임의의 길이로 광선을 쏘고 메쉬가 맞았는지 안맞았는지

광선을 시각적으로 그려야함
geometry로 광선을 표현한다는 뜻

실제 광선은아니고 raycaster에서 쏘는 광선은 보이지 않기 때문에 어디로 지ㅏㄴ는지 시각적으로 보이도록 raycaster에서 쏘는 광선이랑 똑같은 위치에 geometry로 광선을 그린다는 의미

lineMaterial = new THREE.LineBasicMaterial({color : 'yellow'});
선 모양 geometry 만들기
bufferGeometry라는ㄱ ㅔ있는데, 얘는 미리 모형이 만들어져있지 않고 임의로 포인트를 설정해서 그 포인트를 이어주면서 geometry형태를 만들어줄 수 있음
직선은 점과 점의 이은 선이니까 점 두개가 있어야함
const points = [];

점 두개 위치를 points에 넣기
points.push(new THREE.Vector3(0, 0, 100));
화면 바깥쪽이 되고, 화면 안쪽으로 하려면 -100

lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
배열에 들어있는 점들의 위치를 기반으로 geomtry가 세팅이 됨
new THREE.Line(lineGeometry, lineMaterial);

평면상에서 아래로 가는 것처럼 보이지만
화면 저 깊숙한 곳으로 쏘는 것

카메라 위치를 바꾸면 올라가ㅡㄴ 것처럼 보임

boxGeometry도 하나 추가하기
torus geometry도 하나 더(도너츠 형태)
생성자에 반지르,ㅁ 두께, segment)


OrbitControls도 추가하기

--> box는 맞았고, torus는 안맞음(가운데가 뚫려있어서)
meshes 배열에 두개 넣기

얘네를움직이게 하면서 광선에 맞았는지 체크할 건데, 배열에 넣어놔야 체크하기가 쉬움



----------------------------------------
특성 광선을 지나는 메쉬 체크하기

raycaster를 만들어줘야함
THREE.Raycaster();

draw함수 안에서 const origin = 위치필요, 위에서 노란 선을 만들어놨으니까 (출발점)
노란 선과 위치를 똑같이 만들어주기

위치ㅡㄴ 0,0,100 / 0,0,-100
raycaster는 origin(시작 위치), 방향을 정해주면 됨
origin = new THREE.Vector3(0,0,100);
direction = new THREE.Vector3(0, 0, -1); (정교화된 방향, 1단위로 만든 방향)
방향이니까 제트로 -100방향이나 -1방향이나 똑같으니까 -1만 써주기
얼마나 더 가냐마냐니까

raycaster.set(origin, direction);
--> 광선 세팅 완료, 확인을 해봐야 하는데

콘솔에 맞았다는걸 출력
raycaster.intersectObjects(meshes);
--> 배열에 있는 메쉬들로 체크를함
--> 2라고 나오는데, 박스는 맞았는데, torus는 안맞는 중임
--> raycaster는 면을 기준으로 체크해서, 박스는 앞면 뒷면 둘다 맞아서 2라고 나옴
boxMesh.name = 'box';
torusMesh.name = torus


intersects.forEach(item => {
	console.log(item);
});
--> foreach문으로 돌면서 name을 출력
item에 object에 mesh가 들어있음, 그 안에 name에 있어서
item.object.name을 출력
--> box만 통과

item.object.material.color.set('red);
--> 맞았다면 빨개져라 --> 박스만 빨개짐

움직이는 상황에서도 잘 체크가 되는지확인

box, torus의 y포지션에 sin 적용
delta말고 elapestedTimeㅇ로
둘다 움직이게 함
--> 둘다 빨개짐

원래색으로 복구해주기
draw함수는 원래 반복이 되니까 그 함수 안에 원래 색으로 돌려주는 코드를 넣으면 됨

방향을 1이 아닌 -100으로 하면,
raycaster가 동작을안함
100으로 하고 싶다면, direction.normalize();를 통해정규화를 시켜줘야 함

전후를 비교해보기 위해 console에 출력해보면
direction.length()를 출력하면
100은 길이가 100이고, 정규화 후에는 길이가 1로 줄어듦

방향은 맞지만 정규화를 해서 바꿔주야 하는데
그냥 -1로 해주면 됨

정규화 자체를 잡기가 어려운 경우가 있을 때에만 정규화를 하면 됨
(x, y, z모두 다른 숫자가 들어가 있는 경우)
